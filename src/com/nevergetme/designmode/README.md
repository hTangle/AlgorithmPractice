## Design Mode

1. ### Proxy模式
    > #### 当代理人无法完成当前工作时， 就将工作交给本人处理，这个时候才会生成本人的那个类。
    > #### 在启动一个大型系统时，不需要启动当前程序不需要的功能，这样可以加快系统的启动速度。
    > #### Http也是一种Proxy模式。
  
2. ### Command模式
    > #### 使用一个类来表示命令
  
3. ### Interpreter模式
    > #### 正则表达式，检索表达式，批处理语言
    
4. ### Iterator模式
    > #### 将遍历和实现分开来

5. ### Adapter模式
    > #### 加个适配器便于复用，类似于电压转换器
    > #### 类适配器直接继承，对象适配器在适配器中存在该对象。
    
6. ### Template Method模式
    > #### 在父类的模板方法中编写算法，无需在子类中编写算法(在父类中规定流程，在子类中实现处理)
    > #### 使用的算法一致，但是算法中调用了abstract函数，这个函数具体实现由子类决定，这就造成了子类的差异。
    
7. ### Factory Method模式
    > #### 父类决定实例的生成方式，但是并不决定所要生成的具体的类，具体的处理全部交给子类负责。这样就可以将生成实例的框架和实际负责生成实例的类解耦。
    
8. ### Singleton模式
    > #### 设置构造函数为私有

9. ### Prototype模式
    > #### 考虑不能够根据类名来生成实例的情况
     > * 对象种类繁多
     > * 难以根据类生成实例
     > * 想解耦框架与生成的实例
    > #### 使用colne的方法来生成实例

10. ### Builder模式
    > #### 首先建造组成这个物体的各个部分，然后分阶段组装
    > #### 实例是抽象类定义了编写文档的方法，然后子类分别实现这些方法并且完成组装
    > #### 通过一个外部类控制Build的组装模式（与Template Method不同，由父类控制）
    
11. ### Abstract Factory mode
    > #### 抽象工厂的工作是将抽象零件组装为抽象产品
    > #### 我们并不关心零件的具体实现，只会关心接口API，仅仅使用接口将零件组装为产品
    > #### 这样的设计模式可以允许我们很快的新增具体的工厂，但是增加零件时则需要对具体的工厂进行修改。
    
12. ### Bridge mode
    > #### 类的功能层次结构：父类具有基本功能，子类中增加新的功能
    > #### 类的实现层次结构：父类声明抽象方法，子类中具体实现。
    > #### Bridge mode就是将以上两个层次连接起来
    
13. ### Strategy mode
    > #### 需要实现的功能一样，但是我们可以使用不同的算法，这样就可以使用一个抽象类定义该算法要实现的功能，然后在不同的子类中具体实现该功能。
    > #### 我在排序算法中实现了该模式

14. ### Composite mode
    > #### 能够使容器与内容具有一致性，创造出递归结构
    > #### 典型应用就是文件目录

15. ### Decorator mode
    > #### 不断为对象添加新的功能，让该对象适用于不同的情况的设计模式
    > #### 例如一个最基本的蛋糕，上面要添加各种水果奶油之类的，从一个最基本的蛋糕，然后不断可以递归调用该对象，就可以生成一个好吃好看的蛋糕了。

16. ### Visitor mode
    > #### 将数据结构与被处理的方法分开来
    
17. ### Chain of Responsibility
    > #### 将很多对象组成一个职责链，然后来了问题，让他们依次处理，处理不了交给下一个人.
    > #### windows 鼠标事件驱动就是这种模式
    > #### 可以弱化发出请求的人和处理请求的人之间的关系
    > #### 可以动态的改变职责链
    > #### 主要是可以处理的人是不确定的，也没办法

18. ### Facade mode
    > #### 将请求与程序分开，直接向程序请求，之后再由程序进行处理
    
19. ### Mediator mode
    > #### 组员向仲裁者报告，仲裁者向组员下达指示
    
20. ### Observer mode
    > #### 当观察的对象状态发生变化时，会通知观察者。观察者事实上是被动的接收通知的。
    
21. ### Memento mode
    > #### 保存对象的状态
    
22. ### State mode
    > #### 用类表示状态
    > #### 使用一个抽象接口来表示状态，然后子类继承该状态实现不同的状态，在另外一个仅仅接收信息并且针对信息进行处理时不需要判断当前状态
    > #### 如果我们能够改变状态类，接收信息的类就根本不知道这些状态是什么了，将这些状态与监控解耦
    
23. ### Flyweight mode
    > #### 共享对象，避免使用new 